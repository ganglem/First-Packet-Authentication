
\section{Evaluation}
\label{sec:eval}

The following section will discuss the advantages and disadvantages of each aforementioned described methods of First Packet Authentication and whether zero trust is present.\par


\subsection{Importance of zero trust}

Before starting with the individual methods, it is crucial to emphasize the advantages all have in common, namely the zero trust system.  Implicit trust stems from an age where once inside physically the network, one authentication suffices.  In our highly digitalized world, which is shifting more and more to cloud technology, the physical location of a system is becoming less and less important.  In most modern enterprises, networks consist more and more of cloud-based services and infrastructure, including connections to mobile and remote hosts, leading to increasing connections to non-conventional IT.  
Thus, it is critical to ensure that only authorized users have access to confidential resources, and zero trust plays a vital role in this approach. The growing cybersecurity threat requires an architectural redesign of networks based on the principles of a zero trust network \cite{7796146}.   \par
Attackers wanting to gain unauthorized access to a network or service can attack anywhere.  However, zero trust disrupts an attacker's strategy of OODA (observe, orient, decide, attack), since with explicit trust, the target is wholly cloaked, and thus no observation can take place.\par


\subsection{Port Knocking as a solid foundation}

%security through obscurity
Port Knocking is a security example that is, in a sense, security through obscurity.  Security through obscurity is a security design in which the principle of how a system works is kept secret.   That is not a wrong design choice; however, relying solely on one principle is the problem.  With this choice, the authentication method itself does not have to be encrypted; nonetheless, it must not be known what the actual method is.  PK is not just another plain text password - at least when used to protect services that listen on a TCP port like SSH.  This makes it more difficult for attack because they will have significant problems breaching the system regardless of their skill level if they know everything except the actual entry point/way to a system.  An attacker will eventually resort to a brute force attack.

%brute force
Thankfully, PK stands strong against brute force attacks.  The average case for a three-port knock requires approximately 141 trillion (65535\textsuperscript{3} / 2) \cite{portwiki} packets to determine the uninterrupted correct sequence.  In combination with limiting knock-attempts, longer and/or more complex sequences and cryptographic hashes, successful port access attempts are challenging.\\\par

%concealment of ports
The concealment of ports is a significant advantage of PK.  Port scanning by a possible attacker is impossible, and no open ports mean no entry into the system.  PK implies that service discovery with tools like Nmap is no longer possible.  The only way in is knowing the correct sequence and types of knocks.  However, this also presents a major disadvantage.  PK is secure until the secret knocks are known.  Once that information is out, and assuming that the information gets into the intent of malice, this security mechanism becomes void, and the system can be breached.\par
Nevertheless, even with all the possible solutions mentioned to make PK secure, the main problem that no paper has mentioned is that it first needs to be transferred over a secure channel for the requesting party to know the knock sequence.  Neither PK nor SPA are a solution for this; yet, this is the first step in the process.  Without knowing the correct knock sequence, DoS takes place for any user.\\\par

%out of order
The Internet is known for various latencies.  Although basic PK might work flawlessly in a local network, the delays in network communication occurring over larger areas suggest a problem when attempting to use the mechanism in practice.
It cannot be ensured that the packets arrive in order; thus, PK suffers from out-of-order packet delivery.  Latency can result in a rearrangement of packets, and weak Internet connections can lead to packet loss. As previously described, any wrong packet will render all the previous and next packets useless, and PK needs to be performed again.  Time delays for each packet might resolve this issue while also slowing the whole process down \cite{PKissues}.  Broadcast or live streaming activities where a fast transmission of packets and no connection between both parties needs to be established is inconvenient with this method.\par
The question of what happens in the case of two users knocking at once must not be overlooked.  The stateful behavior of PK is a smart design choice, as it allows several users from different source IP addresses to be at different stages of PK simultaneously.  This way, the PK daemon can differentiate between knocking clients and authorize each one in turn as the correct knock sequence is received.  This allows a legitimate user that used the correct knock sequence to pass the firewall while the firewall itself is in the middle of port knocks from multiple IP addresses.  From any other IP address, the ports on the firewall will still appear to be closed.  This solves a possible DoS for the users, as each would break the sequence of one another.\\\par

%mitm
Another flaw of PK is that it suffers from attack methods such as man-in-the-middle.  Since the packets are sent in 'clear-text', eavesdropping becomes an obvious exploit.  The correct sequence of knocks can be obtained through packet-sniffing, and performing a replay attack will grant the connection \cite{sushant}. Using cryptographic hashes inside the port knock sequence is a possible solution.  \par
While with PK, it is assumed that the server is secure, the client is known to be a weak point, i.e., if the client is compromised, an attacker can exploit an established connection, and PK offers no protection against that.

%client IP spoofing
Additionally, IP address spoofing of the client is a possible exploit and will result in a DoS for the spoofed user.  Especially hosts with a static IP address are vulnerable to this.\par

%robust knocking daemon
PK is also very reliant on the robustness of the port knocking daemon. The daemon can be an undesirable single point of failure.  Failure of the daemon can deny any access - even legitimate and authenticated users - to the system.  The availability aspect of the CIA security principle becomes void.  Implementations use a monitoring daemon that restarts the failed PK daemon - however, this only delegates the problem and do not resolve the issue.  If the monitoring daemon fails, so does this solution.\par

%brute force
Although rarely implemented, deployed PK results in a significant reduction in the amount of bandwidth consumed by SSH or brute-force attack because a possible attacker is forced to be less stealthy, as 'loud' and repeated knocks are more noticeable in network logging \cite{PKissues}.\\\par


In summary, PK offers a good foundation for FPA; however, it lacks the vital encryption needed to prevent the most common cyberattacks. \par


\subsection{Single Packet Authorization enhances Port Knocking with downsides}


Many of those issues require a solution, and those vulnerabilities were the primary motivators for the development of Single Packet Authorization.  \par
SPA solves most of the problems Port Knocking proposes while retaining all of the benefits Port Knocking offers. Similarly to PK, SPA also follows the zero trust principle in which no information about the system must be disclosed. This alone is, again, a crucial benefit of using SPA.\\\par

Starting with the most notable difference between PK and SPA is that the latter only uses one packet. Subsequently, SPA does not have the issue of out-of-order delivery of packets, as only one packet is needed in the authentication process. However, a single knock over a few has its downside, too. Detecting SPA packets is more difficult than detecting port knocks as SPA packets are less obvious than long and repeated port knocks and contain seemingly random data which can potentially blend in with normal network traffic. However, using fwknop, some indicators could be added to an Intrusion Detection System (IDS) to note that fwknop is in use on the network.  Fwknop packets, by default, go to port 62201, so a rule could be defined to watch for traffic to that port, although this would easily be bypassed by switching to a custom port \cite{jeanquier}.  Alternatively, an IDS can attempt to track fwknop packets by checking the data length of the UDP packets.  A fwknop packet encrypted using AES encryption is 80 to 160 bytes in length.\par
Nevertheless, for example, a packet encrypted using GPG is between 500 and 1600 bytes in length.  Thus, this proposes a possible solution to track SPA packets. An additional advantage over PK is that replay attacks that are possible are now impossible to execute since the payload includes a timestamp.\\\par

Another enhancement SPA offers over PK is the usage of cryptography. PK, as described, are sent in 'plain text' with no encryption or payload. On the other hand, SPA makes intelligent use of the payload and encrypts it additionally. By encrypting the authentication string that contains a hash of the data, the plain text becomes integrity-protected, and thus an attacker would be unable to change the plaintext (through ciphertext manipulation) without those changes being detected.  \par 
Encryption is crucial in today's security, but it comes with much overhead. Essential to understand is that fwknop uses a user-given passphrase in order to hash and encrypt the payload. By default, this renders fwknop to be especially vulnerable to dictionary or brute force attacks. An attacker could intercept the authorization packet and perform a dictionary attack by testing a list of possible passwords and comparing the values.  If the two hash values match, the correct password has been found.  This, in return, requires knowledge of a possible username authorized on the target system. However, since 'root' is a common user, in fact, the 'superuser' or 'administrator', on every Linux machine, unauthorized root access is not too challenging to achieve.  The timestamp needed can be obtained by looking at the computer clock when the packet was intercepted,  and the IP address can be spoofed or recovered from the IP header of the user's UDP packet.   If any dictionary attack is successful, the attacker could authenticate themselves and, e.g. instruct the server to open any port for later access, with no authentication needing to occur; essentially, the system is completely breached. Fwknop can be modified to support any length for passphrases, which would allow users to use long passphrases, significantly reducing the threat of dictionary attacks.  Although this greatly reduces the threat of dictionary attack, a memorable passphrase would have to be 39 characters long before it was of similar strength to an AES 256-bit key \cite{jeanquier}.\par

Security of SPA solely relies on the encryption method used. The hashing algorithm MDA5 sufficed when fwknop and SPA were invented; however, it has evolved to a well-known deprecated and insecure algorithm. In addition, the main drawback to fwknop is that encryption is achieved by using symmetric encryption. This can be solved by using asymmetric cryptography.  Each user has their own private key, which can be used to sign the authorization data when the data is encrypted with the server's public key.  It is trivial to transmit information securely to the server without resorting to the brute-force method involved with symmetric keys.\par

Man-in-the-middle is once again an issue. Since the target IP address lies unencrypted in the UDP header of the packet, it is very easy for the attacker to intercept an authentication packet, change the IP address to insert their own IP address. The result is that the attacker obtains a free pass to the target system, as the IP address is not included in the encryption process. With fwknop, it is possible to grant access to any IP address, and in return, no spoofing would be needed again.  \par
Similarly, an IP spoofing attack can be performed and obtaining an IP address from an authorized user would result in the same attack as mentioned above.\\\par

Another critical issue that both PK and SPA share is the vulnerability of the user. A compromised user renders even the strongest and most layered security mechanisms useless. Without security on every level and at every node, no security is possible. A major downside to all of the discussed methods of securing a system never emphasizes the user. PK, SPA, and TCA surely help create a 'black hole' for any outsider but offers no protection against successfully authenticated and authorized users. All of the approaches ignore the fact that once inside a system, authentication needs to occur. zero trust is only established at the most outer layer by choosing to authorize the first interaction with a system sufficiently. Nevertheless, zero trust needs to be implemented at every given layer to a resource.\\\par

To summarize, SPA offers major advantages over PK while retaining all of the benefits. The inclusion of encryption and a single packet are the key differences in why SPA is superior to PK. However, it heavily relies on the fwknop configuration and encryption strength and offers no zero trust protection once inside the network.\par



\subsection{BlackRidge Technology's Transport Access Control improves TCP}

A subject with TCP does not exchange identity credentials until after a session is fully established.  This design exposes confidential resources to attack.  One can not know whom the network is exchanging information with until the conversation is underway.\par 

Transport Access Control improves TCP and proposes a solution to this vulnerability using cryptographic identity tokens to authenticate TCP requests before the session is fully established.  No exchange takes place unless the requestor displays a pre-determined shared secret.  This is a massive difference between PK and SPA. Whereas the two schemes use existing standards like TCP or UDP, TAC takes the well-established TCP and improves upon it. \\\par 

TAC shares the same advantage as SPA, as the authentication process takes place with one packet, unlike the many loud packets sent by PK. This makes TAC faster and more efficient, as the same result is achieved in one step. The aforementioned token cache is tolerant of packet loss and enables TAC deployments in low bandwidth and high packet loss environments. This eliminates the problem of out-of-order packet delivery that PK features. Note that TAC is a newer approach to PK and SPA. The algorithms used in TAC are highly parallelizable. This enables high scalability to take advantage of today's multi-core and multi-processor systems.\\\par

TAC clients and policy engines can be hosted on a wide variety of platforms.  It works for any network topology or addressing scheme, like IPv4, IPv6, and networks that use the Network Address Translation (NAT) protocol. It is also compatible with dynamic addressing often used with mobile devices. This approach has several advantages, including separation of security policy from the network design (addresses and topologies) \cite{blackridge}. This approach extracts, authenticates, and applies policy to the connection requests. This protects against unauthorized external observation of the network devices and stops any malware within the protected devices.  Zero trust within the devices is a feature that both PK and SPA lack, so this is a significant bonus point for TAC.\par
Security policies can be easily applied to conceal network attacked devices from unauthorized awareness at the earliest possible time.  TAC blocks both known and unknown attack vectors by preventing unauthorized awareness and access.  This approach is high bandwidth and low latency since packet content is not inspected. Network Tokens do not consume otherwise valuable data bandwidth,  as they are embedded in the TCP session request. The combination of TAC and a segmented, multi-tenant network implements a layered defence against cybersecurity threats and contributes to the non-repudiation of data.
These techniques are also well suited to protecting cloud resources such as enterprise-class mainframe computers.  Further, this approach can be applied to protecting the centralized SDN network controller from unauthorized access and enable only authorized SDN controllers to manage and configure the underlying network \cite{blackridge}. \par
TAC is also a more approachable implementation for home networks, where knowledge of handling fwknop is not needed. This is a more passive approach to security than is the case with the approaches mentioned earlier. This way, TAC cloaks and subsequently protects network information such as servers from network disclosure, establishing the zero trust principle. As with all three methods, port scanning is impossible, and a powerful tool like Nmap is rendered useless. TAC works with all TCP based applications and is compatible with existing networking and security infrastructure \cite{blackridge}.\\\par

The most significant weak point of TAC is the considerable reliance on the token used to authenticate an authorized user and proposes several vulnerabilities.\par
First, using a third-party Identity Access Management (IAM) ; compromise on that behalf would break the whole system, as the vital identity token cannot be obtained to complete authentication. Second, an attacker can impersonate the user and complete authentication by spoofing or token sniffing if an attacker gets a valid token. Nevertheless, a token brings benefits, such as that the token prevents replay attacks, as the token is usable only once and expires after a few seconds. In conclusion, the token generation and insertion must be ensured to be secure. \par

To put it briefly, TAC is an approach that differs a lot from Port Knocking implementations. It improves the already existing TCP, unlike the PK schemes that solely rely on it. It is easily implemented in existing infrastructure with no additional overhead. Furthermore, it retains benefits of an external zero trust like the other approaches and extends them to the inside.\\\par
